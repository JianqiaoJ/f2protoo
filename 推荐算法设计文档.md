# Seren音乐推荐系统算法设计文档

## 一、系统概述

Seren音乐推荐系统基于用户偏好、听歌行为和音乐标签（genre、instrument、mood）进行个性化推荐。系统采用**混合推荐策略**，结合内容过滤、协同过滤和基于行为的推荐。

## 二、数据基础

### 2.1 音乐标签数据
- **Genre（风格）**：如 rock, pop, electronic, jazz 等
- **Instrument（乐器）**：如 guitar, piano, drums 等
- **Mood（情绪）**：如 happy, sad, energetic, calm 等
- **Theme（主题）**：如 love, nature, travel 等

### 2.2 用户行为数据
- **听歌时长**：用户实际播放的时长（秒）
- **评分**：1-5星评分
- **收藏状态**：是否收藏歌曲
- **时间戳**：行为发生的时间

### 2.3 用户偏好数据
- **显式偏好**：用户主动输入的偏好（genre、instrument、mood）
- **隐式偏好**：从用户行为中推断的偏好

## 三、推荐算法架构

### 3.1 混合推荐模型

推荐分数由三部分组成：

```
最终推荐分数 = 内容匹配分数 × 0.6 + 行为分数 × 0.3 + 多样性分数 × 0.1
```

### 3.2 内容匹配算法（Content-Based Filtering）

#### 3.2.1 标签匹配分数计算

```javascript
function calculateContentScore(trackTags, userPreferences) {
  let score = 0;
  
  // 1. Genre匹配（权重：3.0）
  const genreMatches = trackTags.genres.filter(g => 
    userPreferences.genres.includes(g)
  ).length;
  score += genreMatches * 3.0;
  
  // 2. Instrument匹配（权重：2.0）
  const instrumentMatches = trackTags.instruments.filter(i => 
    userPreferences.instruments.includes(i)
  ).length;
  score += instrumentMatches * 2.0;
  
  // 3. Mood匹配（权重：2.0）
  const moodMatches = trackTags.moods.filter(m => 
    userPreferences.moods.includes(m)
  ).length;
  score += moodMatches * 2.0;
  
  // 4. Theme匹配（权重：1.0）
  const themeMatches = trackTags.themes.filter(t => 
    userPreferences.themes.includes(t)
  ).length;
  score += themeMatches * 1.0;
  
  // 5. 标签覆盖率加成
  const totalTags = trackTags.genres.length + 
                    trackTags.instruments.length + 
                    trackTags.moods.length + 
                    trackTags.themes.length;
  if (totalTags > 0) {
    const matchedTags = genreMatches + instrumentMatches + moodMatches + themeMatches;
    const coverage = matchedTags / totalTags;
    score *= (1 + coverage * 0.2); // 覆盖率加成最高20%
  }
  
  return score;
}
```

#### 3.2.2 标签权重说明

| 标签类型 | 权重 | 原因 |
|---------|------|------|
| Genre | 3.0 | 音乐风格是用户最直观的偏好，影响最大 |
| Instrument | 2.0 | 乐器偏好反映用户对音色的喜好 |
| Mood | 2.0 | 情绪匹配影响用户当下的听歌体验 |
| Theme | 1.0 | 主题是辅助因素，权重较低 |

### 3.3 基于行为的推荐（Behavior-Based）

#### 3.3.1 隐式偏好提取

从用户历史行为中提取隐式偏好：

```javascript
function extractImplicitPreferences(behaviorHistory) {
  const tagWeights = {
    genres: new Map(),
    instruments: new Map(),
    moods: new Map(),
    themes: new Map()
  };
  
  behaviorHistory.forEach(record => {
    // 计算行为权重
    const behaviorWeight = calculateBehaviorWeight(
      record.rating,
      record.listen_duration,
      record.is_favorited
    );
    
    // 获取歌曲标签
    const trackTags = getTrackTags(record.track_id);
    if (trackTags) {
      // 累加标签权重
      trackTags.genres.forEach(g => {
        tagWeights.genres.set(g, 
          (tagWeights.genres.get(g) || 0) + behaviorWeight
        );
      });
      // 同样处理 instruments, moods, themes
    }
  });
  
  // 返回Top N标签作为隐式偏好
  return {
    genres: getTopNTags(tagWeights.genres, 5),
    instruments: getTopNTags(tagWeights.instruments, 5),
    moods: getTopNTags(tagWeights.moods, 5),
    themes: getTopNTags(tagWeights.themes, 5)
  };
}
```

#### 3.3.2 行为权重计算

```javascript
function calculateBehaviorWeight(rating, duration, isFavorited) {
  // 评分权重：5星=1.0, 4星=0.8, 3星=0.5, 2星=0.2, 1星=0.1
  const ratingWeight = rating === 5 ? 1.0 :
                       rating === 4 ? 0.8 :
                       rating === 3 ? 0.5 :
                       rating === 2 ? 0.2 : 0.1;
  
  // 听歌时长权重
  // 超过60秒=1.0, 30-60秒=0.7, 10-30秒=0.4, <10秒=0.1
  const durationWeight = duration >= 60 ? 1.0 :
                         duration >= 30 ? 0.7 :
                         duration >= 10 ? 0.4 : 0.1;
  
  // 收藏权重：收藏=1.5倍加成
  const favoriteWeight = isFavorited ? 1.5 : 1.0;
  
  // 综合权重：评分60% + 时长30% + 收藏10%
  return (ratingWeight * 0.6 + durationWeight * 0.3) * favoriteWeight;
}
```

#### 3.3.3 行为分数计算

对于候选歌曲，计算其与用户历史行为的匹配度：

```javascript
function calculateBehaviorScore(trackId, behaviorHistory) {
  let score = 0;
  let count = 0;
  
  // 找到用户听过的相似歌曲
  behaviorHistory.forEach(record => {
    if (record.track_id === trackId) {
      // 如果用户听过这首歌，根据行为计算分数
      const behaviorWeight = calculateBehaviorWeight(
        record.rating,
        record.listen_duration,
        record.is_favorited
      );
      score += behaviorWeight;
      count++;
    } else {
      // 计算标签相似度
      const similarity = calculateTagSimilarity(
        getTrackTags(trackId),
        getTrackTags(record.track_id)
      );
      if (similarity > 0.5) {
        // 如果标签相似度高，根据用户对相似歌曲的行为给予分数
        const behaviorWeight = calculateBehaviorWeight(
          record.rating,
          record.listen_duration,
          record.is_favorited
        );
        score += similarity * behaviorWeight;
        count++;
      }
    }
  });
  
  return count > 0 ? score / count : 0;
}
```

### 3.4 偏好合并策略

合并显式偏好和隐式偏好：

```javascript
function combinePreferences(explicitPrefs, implicitPrefs) {
  // 显式偏好权重：70%
  // 隐式偏好权重：30%
  const explicitWeight = 0.7;
  const implicitWeight = 0.3;
  
  return {
    genres: mergeTagLists(
      explicitPrefs.genres, 
      implicitPrefs.genres,
      explicitWeight,
      implicitWeight
    ),
    instruments: mergeTagLists(
      explicitPrefs.instruments,
      implicitPrefs.instruments,
      explicitWeight,
      implicitWeight
    ),
    moods: mergeTagLists(
      explicitPrefs.moods,
      implicitPrefs.moods,
      explicitWeight,
      implicitWeight
    ),
    themes: mergeTagLists(
      explicitPrefs.themes,
      implicitPrefs.themes,
      explicitWeight,
      implicitWeight
    )
  };
}
```

### 3.5 多样性保证

避免推荐过于相似的歌曲：

```javascript
function ensureDiversity(recommendedTracks, maxSimilarity = 0.7) {
  const diverseTracks = [];
  
  recommendedTracks.forEach(trackId => {
    const trackTags = getTrackTags(trackId);
    if (!trackTags) return;
    
    // 检查与已推荐歌曲的相似度
    const isDiverse = diverseTracks.every(existingId => {
      const existingTags = getTrackTags(existingId);
      if (!existingTags) return true;
      
      const similarity = calculateTagSimilarity(trackTags, existingTags);
      return similarity < maxSimilarity;
    });
    
    if (isDiverse) {
      diverseTracks.push(trackId);
    }
  });
  
  return diverseTracks;
}

function calculateTagSimilarity(tags1, tags2) {
  // 计算Jaccard相似度
  const allTags1 = new Set([
    ...tags1.genres,
    ...tags1.instruments,
    ...tags1.moods,
    ...tags1.themes
  ]);
  const allTags2 = new Set([
    ...tags2.genres,
    ...tags2.instruments,
    ...tags2.moods,
    ...tags2.themes
  ]);
  
  const intersection = new Set([...allTags1].filter(x => allTags2.has(x)));
  const union = new Set([...allTags1, ...allTags2]);
  
  return union.size > 0 ? intersection.size / union.size : 0;
}
```

### 3.6 冷启动处理

#### 3.6.1 新用户（无行为数据）
- 仅使用显式偏好进行推荐
- 如果显式偏好为空，推荐热门标签的歌曲

#### 3.6.2 少量行为数据（<5条记录）
- 显式偏好权重：80%
- 隐式偏好权重：20%

#### 3.6.3 丰富行为数据（≥5条记录）
- 显式偏好权重：60%
- 隐式偏好权重：40%

## 四、推荐流程

### 4.1 完整推荐流程

```
1. 获取用户数据
   ├─ 显式偏好（userPreferences）
   ├─ 行为历史（behaviorHistory）
   └─ 当前播放歌曲（currentTrack）

2. 提取隐式偏好
   └─ 从行为历史中提取标签权重

3. 合并偏好
   └─ 显式偏好 + 隐式偏好（根据数据量调整权重）

4. 计算候选歌曲分数
   ├─ 内容匹配分数（基于标签匹配）
   ├─ 行为分数（基于历史行为）
   └─ 多样性分数（避免重复推荐）

5. 排序和筛选
   ├─ 按最终分数降序排序
   ├─ 过滤已听过的歌曲（可选）
   ├─ 确保多样性
   └─ 返回Top N推荐

6. 返回推荐结果
   └─ 返回推荐歌曲ID列表
```

### 4.2 推荐算法伪代码

```javascript
function generateRecommendations(username, currentTrackId, count = 10) {
  // 1. 获取用户数据
  const explicitPrefs = getUserPreferences(username);
  const behaviorHistory = getUserBehaviorHistory(username);
  const allTrackIds = getAllTrackIds();
  
  // 2. 提取隐式偏好
  const implicitPrefs = extractImplicitPreferences(behaviorHistory);
  
  // 3. 合并偏好
  const combinedPrefs = combinePreferences(explicitPrefs, implicitPrefs);
  
  // 4. 计算所有候选歌曲的分数
  const scoredTracks = allTrackIds.map(trackId => {
    const trackTags = getTrackTags(trackId);
    if (!trackTags) return { trackId, score: 0 };
    
    // 内容匹配分数
    const contentScore = calculateContentScore(trackTags, combinedPrefs);
    
    // 行为分数
    const behaviorScore = calculateBehaviorScore(trackId, behaviorHistory);
    
    // 最终分数
    const finalScore = contentScore * 0.6 + behaviorScore * 0.3;
    
    return { trackId, score: finalScore, trackTags };
  });
  
  // 5. 排序
  scoredTracks.sort((a, b) => b.score - a.score);
  
  // 6. 过滤和多样性处理
  const filteredTracks = scoredTracks
    .filter(t => t.score > 0) // 只保留有分数的
    .filter(t => t.trackId !== currentTrackId) // 排除当前歌曲
    .filter(t => !isRecentlyListened(t.trackId, behaviorHistory)); // 排除最近听过的
  
  const diverseTracks = ensureDiversity(
    filteredTracks.map(t => t.trackId),
    0.7
  );
  
  // 7. 返回Top N
  return diverseTracks.slice(0, count);
}
```

## 五、特殊规则

### 5.1 低评分处理
- 如果用户对某首歌评分为1-2星，系统会：
  1. 识别该歌曲的genre标签
  2. 降低该genre的推荐权重
  3. 在推荐时减少该genre歌曲的出现频率

### 5.2 高评分/长听歌时长处理
- 如果用户对某首歌评分≥4星或听歌时长≥60秒：
  1. 提取该歌曲的所有标签
  2. 提高这些标签的推荐权重
  3. 优先推荐具有相似标签的歌曲

### 5.3 收藏歌曲处理
- 收藏的歌曲：
  1. 其标签权重提升1.5倍
  2. 优先推荐具有相似标签的歌曲
  3. 但不会重复推荐已收藏的歌曲本身

## 六、性能优化

### 6.1 缓存策略
- 用户偏好缓存：5分钟
- 推荐结果缓存：2分钟
- 标签映射缓存：永久（除非数据更新）

### 6.2 计算优化
- 只计算Top 100候选歌曲的详细分数
- 使用索引加速标签匹配
- 批量查询数据库减少I/O

## 七、评估指标

### 7.1 推荐质量指标
- **点击率（CTR）**：推荐歌曲被播放的比例
- **平均听歌时长**：推荐歌曲的平均播放时长
- **收藏率**：推荐歌曲被收藏的比例
- **评分分布**：推荐歌曲的评分分布

### 7.2 多样性指标
- **标签覆盖率**：推荐歌曲覆盖的标签数量
- **相似度分布**：推荐歌曲之间的平均相似度

## 八、未来优化方向

1. **协同过滤**：基于相似用户的推荐
2. **深度学习**：使用神经网络学习用户偏好
3. **实时推荐**：根据用户当前行为实时调整推荐
4. **上下文感知**：考虑时间、地点等上下文因素
5. **多目标优化**：同时优化准确性和多样性

## 九、API接口设计

### 9.1 推荐接口

**POST /api/recommend**

请求参数：
```json
{
  "username": "user1",
  "currentTrackId": "track_0000214",
  "count": 10
}
```

响应：
```json
{
  "success": true,
  "recommendedTracks": [
    "track_0000215",
    "track_0000234",
    ...
  ],
  "explanation": {
    "contentScore": 8.5,
    "behaviorScore": 2.3,
    "finalScore": 5.79
  }
}
```

---

**文档版本**：v1.0  
**最后更新**：2024年
